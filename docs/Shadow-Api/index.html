<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Shadow Api :: Shadow Api</title>
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
    <nav class="navbar">
        <div class="navbar-brand">
            <div class="navbar-item">
                <a href="#">Shadow Api</a>
            </div>
        </div>
        <div id="topbar-nav" class="navbar-menu">
            <div class="navbar-end">
                <a class="navbar-item" href="index.html">Home</a>
                <a class="navbar-item" href="Annotation%20Processing.html">Implementations</a>
                <a class="navbar-item" href="article/Meta%20Model.html">Articles</a>
                <a class="navbar-item" href="https://github.com/LukasDetermann/shadow">
                    <span class="icon">
                        <svg aria-hidden="true" data-icon="github" role="img" xmlns="http://www.w3.org/2000/svg"
                             viewBox="0 0 98 96">
                            <path fill-rule="evenodd"
                                  clip-rule="evenodd"
                                  d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z"
                                  fill="#fff"/>
                        </svg>
                    </span>
                </a>
            </div>
        </div>
    </nav>
</header><div class="body">
<div class="nav-container" data-component="Shadow-Api" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="index.html">Shadow-Api</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Implementations</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Annotation%20Processing.html">Annotation Processing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Reflection.html">reflection</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="java.lang.model.html">java.lang.model</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Articles</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="article/ConsistencyTest.html">Consistency Testing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="article/Meta%20Model.html">Meta Model</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="article/AptLoading.html">Annotation Processor loading</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link is-current"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Shadow-Api</a></li>
    <li><a href="index.html">Shadow Api</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Shadow Api</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Java SE and the Java ecosystem offer a multitude of Metaprogramming Apis.
They serve the same purpose just in different contexts.
Annotation processing to analyse classes in the during compilation process, or Reflection to do the same at runtime.
Each having unique concepts and quirks.
This makes Metaprogramming harder to understand and creates a maintenance overhead.
It&#8217;s very hard to switch from one Api to another.
Once something is written with java.lang.reflect it&#8217;s hard to change it to an Annotation Processor.
Some JDK Apis are not up to the normal standard.</p>
</div>
<div class="paragraph">
<p>This project is an Abstraction for Metaprogramming</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/Overview.svg" alt="Overview" width="80%">
</div>
</div>
<div class="paragraph">
<p>It has two Types of Apis</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_general_purpose_api"><a class="anchor" href="#_general_purpose_api"></a>General Purpose Api</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This Api works with any kind of Metaprogramming, but the featureset is limited to common operations</p>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>The Api is request based.
As a caller you can request for example a field of a class.
Accessing fields may or may not be supported.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
void request()
{
   //adapter for the reflection api
   C_Class systemClass = R_Adapter.generalize(System.class);
   //request the field "out" for the class java.lang.System
   Response&lt;C_Field&gt; out = Provider.request(systemClass,
                                            Operations.DECLARED_GET_FIELD,
                                            "out");

   switch (out)
   {
      //the implementation may not support this operation
      //e.g. it's impossible to access fields with reflection
      case Response.Unsupported&lt;C_Field&gt; unsupported -&gt; Assertions.fail();
      //the implementation may support this operation, but there is no
      //result for this instance
      //e.g. the class java.lang.System does not have a field called "out"
      case Response.Empty&lt;C_Field&gt; empty -&gt; Assertions.fail();
      //accessing fields via reflection is possible and java.lang.System
      //does have a field called "out" therefore a result is expected
      case Response.Result&lt;C_Field&gt; result -&gt; assertNotNull(result.value());
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or use a convenience method if <code>Optional.empty()</code> or throwing an Exception is a fitting default behavior.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
void requestOrEmpty()
{
   //adapter for the reflection api
   C_Class systemClass = R_Adapter.generalize(System.class);
   //request the field "out" for the class java.lang.System.
   //If its unsupported an Empty Optional is returned
   Optional&lt;C_Field&gt; out = Provider.requestOrEmpty(systemClass,
                                                   Operations.DECLARED_GET_FIELD,
                                                   "out");

   assertTrue(out.isPresent());
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
void requestOrThrow()
{
   //adapter for the reflection api
   C_Class systemClass = R_Adapter.generalize(System.class);
   //request the field "out" for the class java.lang.System.
   //If its unsupported an Exception is thrown
   C_Field out = Provider.requestOrThrow(systemClass,
                                         Operations.DECLARED_GET_FIELD,
                                         "out");

   assertNotNull(out);
}</code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
<div class="sect1">
<h2 id="_specific_apis"><a class="anchor" href="#_specific_apis"></a>Specific Apis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There is one Api for each kind of Metaprogramming.
One for Annotation processing and another very similar one for reflection.
Each being able to support the complete featureset.</p>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="listingblock">
<div class="title">This Annotation Processor generates Builder</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.determann.shadow.builder;

import io.determann.shadow.api.annotation_processing.AP_Context;
import io.determann.shadow.api.annotation_processing.AP_Processor;
import io.determann.shadow.api.lang_model.shadow.LM_Nameable;
import io.determann.shadow.api.lang_model.shadow.LM_QualifiedNameable;
import io.determann.shadow.api.lang_model.shadow.structure.LM_Property;
import io.determann.shadow.api.lang_model.shadow.type.LM_Class;
import io.determann.shadow.api.lang_model.shadow.type.LM_Type;

import java.util.List;
import java.util.stream.Collectors;

import static org.apache.commons.lang3.StringUtils.capitalize;
import static org.apache.commons.lang3.StringUtils.uncapitalize;

/**
 * Builds a companion Builder class for each annotated class
 */
public class ShadowBuilderProcessor extends AP_Processor
{
   @Override
   public void process(final AP_Context context)
   {
      //iterate over every class annotated with the BuilderPattern annotation
      for (LM_Class aClass : context
            .getClassesAnnotatedWith("io.determann.shadow.builder.BuilderPattern"))
      {
         String toBuildQualifiedName = aClass.getQualifiedName();
         //qualifiedName of the companion builder class
         String builderQualifiedName = toBuildQualifiedName + "ShadowBuilder";
         //simpleName of the companion builder class
         String builderSimpleName = aClass.getName() + "ShadowBuilder";
         String builderVariableName = uncapitalize(builderSimpleName);

         //create a record holding the code needed to render a property in the builder
         List&lt;BuilderElement&gt; builderElements =
               aClass.getProperties()
                     .stream()
                     .filter(LM_Property::isMutable)
                     .map(property -&gt; renderProperty(builderSimpleName,
                                                     builderVariableName,
                                                     property))
                     .toList();

         //writes the builder
         context.writeAndCompileSourceFile(builderQualifiedName,
                                           renderBuilder(aClass,
                                                         toBuildQualifiedName,
                                                         builderSimpleName,
                                                         builderVariableName,
                                                         builderElements));
      }
   }

   /**
    * renders a companion builder class
    */
   private String renderBuilder(final LM_Class aClass,
                                final String toBuildQualifiedName,
                                final String builderSimpleName,
                                final String builderVariableName,
                                final List&lt;BuilderElement&gt; builderElements)
   {
      String fields = builderElements.stream()
                                     .map(BuilderElement::field)
                                     .collect(Collectors.joining("\n\n"));

      String mutators = builderElements.stream()
                                       .map(BuilderElement::mutator)
                                       .collect(Collectors.joining("\n\n"));

      String setterInvocations = builderElements.stream()
                                                .map(BuilderElement::toBuildSetter)
                                                .collect(Collectors.joining("\n\n"));
      return """
            package %1$s;
                  
            public class %2$s{
               %3$s
                  
            %4$s
                  
               public %5$s build() {
                  %5$s %6$s = new %5$s();
                  %7$s
                  return %6$s;
               }
            }
            """.formatted(aClass.getPackage().getQualifiedName(),
                          builderSimpleName,
                          fields,
                          mutators,
                          toBuildQualifiedName,
                          builderVariableName,
                          setterInvocations);
   }

   /**
    * Creates a {@link BuilderElement} for each property of the annotated pojo
    */
   private BuilderElement renderProperty(final String builderSimpleName,
                                         final String builderVariableName,
                                         final LM_Property property)
   {
      String propertyName = property.getName();
      String type = renderType(property.getType());
      String field = "private " + type + " " + propertyName + ";";

      String mutator = """
               public %1$s with%2$s(%3$s %4$s) {
                  this.%4$s = %4$s;
                  return this;
               }
            """.formatted(builderSimpleName,
                          capitalize(propertyName),
                          type,
                          propertyName);

      String toBuildSetter = builderVariableName + "." +
                             property.getSetterOrThrow().getName() +
                             "(" + propertyName + ");";

      return new BuilderElement(field, mutator, toBuildSetter);
   }

   /**
    * Used to render the code needed to render a property in the builder
    *
    * @param field ones rendered will hold the values being used to build the pojo
    * @param mutator ones rendered will set the value of the {@link #field}
    * @param toBuildSetter ones rendered will modify the build pojo
    */
   private record BuilderElement(String field,
                                 String mutator,
                                 String toBuildSetter) {}

   private static String renderType(LM_Type type)
   {
      if (type instanceof LM_QualifiedNameable qualifiedNameable)
      {
         return qualifiedNameable.getQualifiedName();
      }
      if (type instanceof LM_Nameable nameable)
      {
         return nameable.getName();
      }
      return type.toString();
   }
}</code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
<div class="sect1">
<h2 id="_supported"><a class="anchor" href="#_supported"></a>Supported</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="Annotation%20Processing.html" class="xref page">Annotation Processing</a></p>
</li>
<li>
<p><a href="java.lang.model.html" class="xref page">java.lang.model</a></p>
</li>
<li>
<p><a href="Reflection.html" class="xref page">reflection</a> (experimental)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_next_goals"><a class="anchor" href="#_next_goals"></a>Next Goals</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Improve Annotation Processing Support</p>
<div class="ulist">
<ul>
<li>
<p>Add a Java DSL Api for Rendering</p>
</li>
<li>
<p>Add support for specific Annotations</p>
</li>
</ul>
</div>
</li>
<li>
<p>Improve Support for other Metaprogramming Apis</p>
<div class="ulist">
<ul>
<li>
<p>Move more of the implementation to the <code>shadow-implementation-support</code>
module for better consistency and easier support of multiple
implementations</p>
</li>
<li>
<p>Support the complete Lexical Structure</p>
</li>
<li>
<p>Create a maven archetype to reduce the effort of supporting new
Metaprogramming Implementations</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
    <p>The Ui for this site is based in part on the <a href="https://gitlab.com/antora/antora-ui-default">Antora Default UI</a></p>
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>
<script async src="../_/js/vendor/highlight.js"></script>
  </body>
</html>
